<!DOCTYPE html>
<html>
<head>
  <title>Advanced Driver Location Recorder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 500px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    
    .header {
      background: linear-gradient(45deg, #ff6b6b, #ffa500);
      color: white;
      padding: 30px 20px;
      text-align: center;
    }
    
    .header h1 {
      font-size: 24px;
      margin-bottom: 10px;
    }
    
    .status-indicator {
      display: inline-block;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: bold;
      background: rgba(255,255,255,0.2);
    }
    
    .content {
      padding: 30px 20px;
    }
    
    .timer-section {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .timer-display {
      font-size: 48px;
      font-weight: bold;
      color: #333;
      margin-bottom: 10px;
      font-family: 'Courier New', monospace;
    }
    
    .timer-label {
      color: #666;
      font-size: 14px;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 30px;
    }
    
    .stat-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      border-left: 4px solid #007bff;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #007bff;
      margin-bottom: 5px;
    }
    
    .stat-label {
      color: #666;
      font-size: 12px;
    }
    
    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
    }
    
    .btn {
      flex: 1;
      padding: 15px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .btn-start {
      background: #28a745;
      color: white;
    }
    
    .btn-start:hover {
      background: #218838;
      transform: translateY(-2px);
    }
    
    .btn-stop {
      background: #dc3545;
      color: white;
    }
    
    .btn-stop:hover {
      background: #c82333;
      transform: translateY(-2px);
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .signal-status {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .signal-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .signal-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    .signal-good { background: #28a745; }
    .signal-weak { background: #ffc107; }
    .signal-lost { background: #dc3545; }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .bus-id-section {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .bus-id-label {
      display: block;
      font-size: 14px;
      font-weight: bold;
      color: #333;
      margin-bottom: 8px;
    }
    
    .bus-id-input {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      background: white;
      color: #333;
      transition: border-color 0.3s ease;
    }
    
    .bus-id-input:focus {
      outline: none;
      border-color: #007bff;
      box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
    }
    
    .bus-id-input::placeholder {
      color: #999;
      font-weight: normal;
    }
    
    .bus-id-input:disabled {
      background: #f5f5f5;
      color: #666;
      cursor: not-allowed;
      border-color: #ccc;
    }
    
    .coordinates-preview {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 15px;
      max-height: 150px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }
    
    .coordinate-entry {
      margin-bottom: 5px;
      color: #666;
    }
    
    .auto-sync-status {
      background: #e7f3ff;
      border: 1px solid #b3d9ff;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
    }
    
    .sync-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .loading-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #007bff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üöç Driver Location Recorder</h1>
      <div class="status-indicator" id="recordingStatus">
        ‚≠ï Ready to Start
      </div>
    </div>
    
    <div class="content">
      <!-- Timer Section -->
      <div class="timer-section">
        <div class="timer-display" id="timerDisplay">00:00:00</div>
        <div class="timer-label">Recording Time</div>
      </div>
      
      <!-- Stats Grid -->
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-value" id="coordinateCount">0</div>
          <div class="stat-label">COORDINATES</div>
        </div>
        <div class="stat-card">
          <div class="stat-value" id="autoSyncCount">0</div>
          <div class="stat-label">OPTIMIZATIONS</div>
        </div>
      </div>
      
      <!-- Signal Status -->
      <div class="signal-status">
        <div class="signal-indicator">
          <div class="signal-dot signal-good" id="signalDot"></div>
          <span id="signalText">GPS Signal: Searching...</span>
        </div>
        <div style="font-size: 12px; color: #666;" id="signalDetails">
          Accuracy: -- | Last Update: --
        </div>
      </div>
      
      <!-- Bus ID Input -->
      <div class="bus-id-section">
        <label class="bus-id-label" for="busIdInput">
          üöå Bus ID
        </label>
        <input 
          type="text" 
          class="bus-id-input" 
          id="busIdInput" 
          placeholder="Enter Bus ID (e.g., BUS1234)"
          maxlength="20"
          required
        />
      </div>
      
      <!-- Controls -->
      <div class="controls">
        <button class="btn btn-start" id="startBtn">
          ‚ñ∂Ô∏è Start Recording
        </button>
        <button class="btn btn-stop" id="stopBtn" disabled>
          ‚èπÔ∏è Stop & Send
        </button>
      </div>
      
      <!-- Auto Sync Status -->
      <div class="auto-sync-status" id="autoSyncStatus" style="display: none;">
        <div class="sync-indicator">
          <div class="loading-spinner"></div>
          <span>Auto-syncing coordinates...</span>
        </div>
      </div>
      
      <!-- Coordinates Preview -->
      <div style="margin-top: 20px;">
        <h4 style="margin-bottom: 10px; color: #333;">üìç Latest Coordinates</h4>
        <div class="coordinates-preview" id="coordinatesPreview">
          No coordinates recorded yet...
        </div>
      </div>
    </div>
  </div>

  <script>
    let coordinates = [];
    let allCoordinates = []; // Main array storing all coordinates
    let watchId = null;
    let startTime = null;
    let timerInterval = null;
    let autoSyncCount = 0;
    let optimizationCount = 0; // Track number of optimizations
    let lastSuccessfulSync = null;
    let signalLostTimeout = null;
    let isRecording = false;
    let lastOptimizationTime = null;

    // DOM Elements
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const timerDisplay = document.getElementById('timerDisplay');
    const recordingStatus = document.getElementById('recordingStatus');
    const coordinateCount = document.getElementById('coordinateCount');
    const autoSyncCountDisplay = document.getElementById('autoSyncCount');
    const signalDot = document.getElementById('signalDot');
    const signalText = document.getElementById('signalText');
    const signalDetails = document.getElementById('signalDetails');
    const coordinatesPreview = document.getElementById('coordinatesPreview');
    const autoSyncStatus = document.getElementById('autoSyncStatus');

    // API Configuration
    const API_ENDPOINTS = {
      primary: 'https://where-is-mybus.onrender.com/api/buses/make-route',
      // primary:'http://localhost:5001/api/buses/make-route',
      backup: 'https://your-backup-api.com/api/routes',
      emergency: 'https://emergency-backup.com/api/save'
    };

    // Douglas-Peucker Algorithm for Route Optimization
    function douglasPeucker(points, epsilon = 0.00001) {
      if (points.length <= 2) return points;
      
      // Find the point with maximum distance from line between first and last
      let maxDistance = 0;
      let maxIndex = 0;
      const start = points[0];
      const end = points[points.length - 1];
      
      for (let i = 1; i < points.length - 1; i++) {
        const distance = perpendicularDistance(points[i], start, end);
        if (distance > maxDistance) {
          maxDistance = distance;
          maxIndex = i;
        }
      }
      
      // If max distance is greater than epsilon, recursively simplify
      if (maxDistance > epsilon) {
        const leftPart = douglasPeucker(points.slice(0, maxIndex + 1), epsilon);
        const rightPart = douglasPeucker(points.slice(maxIndex), epsilon);
        
        // Combine results (remove duplicate point at junction)
        return leftPart.slice(0, -1).concat(rightPart);
      } else {
        // All points between start and end can be removed
        return [start, end];
      }
    }

    // Calculate perpendicular distance from point to line
    function perpendicularDistance(point, lineStart, lineEnd) {
      const x0 = point.lat;
      const y0 = point.lng;
      const x1 = lineStart.lat;
      const y1 = lineStart.lng;
      const x2 = lineEnd.lat;
      const y2 = lineEnd.lng;
      
      const A = x2 - x1;
      const B = y2 - y1;
      const C = x1 - x0;
      const D = y1 - y0;
      
      const dot = A * C + B * D;
      const lenSq = A * A + B * B;
      
      if (lenSq === 0) {
        // Line start and end are the same point
        return Math.sqrt(C * C + D * D);
      }
      
      const param = dot / lenSq;
      let closestX, closestY;
      
      if (param < 0) {
        closestX = x1;
        closestY = y1;
      } else if (param > 1) {
        closestX = x2;
        closestY = y2;
      } else {
        closestX = x1 + param * A;
        closestY = y1 + param * B;
      }
      
      const dx = x0 - closestX;
      const dy = y0 - closestY;
      
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Route Optimization Function (Every 2 Minutes for All Coordinates)
    function optimizeRoute() {
      if (allCoordinates.length < 3) return;
      
      const originalCount = allCoordinates.length;
      console.log(`üîß Starting route optimization for all coordinates. Original points: ${originalCount}`);
      
      // Always count optimization attempts for user feedback
      optimizationCount++;
      autoSyncCount = optimizationCount;
      autoSyncCountDisplay.textContent = optimizationCount;
      
      // Analyze route characteristics
      const routeAnalysis = analyzeRoute(allCoordinates);
      
      // Primary optimization: Target straight line segments while preserving curves
      let optimized = optimizeStraightLines(allCoordinates);
      let reductionPercentage = ((originalCount - optimized.length) / originalCount) * 100;
      
      console.log(`üìä Optimization result: ${originalCount} ‚Üí ${optimized.length} points (${reductionPercentage.toFixed(1)}% reduction)`);
      
      // Apply optimization to all coordinates regardless of dataset size
      allCoordinates = optimized;
      coordinates = optimized.slice(-5); // Keep last 5 for preview
      
      // Save to local storage for safety
      saveToLocalStorage();
      
      // Update display
      updateCoordinatesDisplay();
      
      // Show optimization status
      showOptimizationStatus(originalCount, optimized.length, reductionPercentage, 'applied');
    }

    // Calculate adaptive epsilon based on route characteristics
    function calculateAdaptiveEpsilon(points) {
      if (points.length < 2) return 0.0001;
      
      // Calculate average distance between consecutive points
      let totalDistance = 0;
      for (let i = 1; i < points.length; i++) {
        const dist = getDistance(points[i-1], points[i]);
        totalDistance += dist;
      }
      const avgDistance = totalDistance / (points.length - 1);
      
      // Calculate route span (bounding box)
      const lats = points.map(p => p.lat);
      const lngs = points.map(p => p.lng);
      const latSpan = Math.max(...lats) - Math.min(...lats);
      const lngSpan = Math.max(...lngs) - Math.min(...lngs);
      const routeSpan = Math.max(latSpan, lngSpan);
      
      // Adaptive epsilon: larger for longer routes, smaller for precise tracking
      let epsilon = Math.max(routeSpan * 0.001, avgDistance * 0.5);
      
      // Minimum threshold (about 5 meters)
      epsilon = Math.max(epsilon, 0.00005);
      
      // Maximum threshold (about 50 meters)
      epsilon = Math.min(epsilon, 0.0005);
      
      console.log(`üìê Route analysis: ${points.length} points, avg distance: ${(avgDistance * 111000).toFixed(1)}m, span: ${(routeSpan * 111000).toFixed(1)}m`);
      
      return epsilon;
    }

    // Get distance between two points in degrees
    function getDistance(point1, point2) {
      const dx = point2.lat - point1.lat;
      const dy = point2.lng - point1.lng;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Detect straight line segments for targeted optimization
    function detectStraightLineSegments(points, threshold = 0.00002) {
      if (points.length < 3) return [];
      
      const segments = [];
      let currentSegment = [0]; // Start with first point index
      
      for (let i = 1; i < points.length - 1; i++) {
        const prev = points[i - 1];
        const current = points[i];
        const next = points[i + 1];
        
        // Calculate deviation from straight line
        const deviation = perpendicularDistance(current, prev, next);
        
        if (deviation < threshold) {
          // Point is on straight line
          currentSegment.push(i);
        } else {
          // Curve detected - end current segment if it has enough points
          if (currentSegment.length >= 3) {
            currentSegment.push(i); // Include the curve point as end
            segments.push([...currentSegment]);
          }
          currentSegment = [i]; // Start new segment
        }
      }
      
      // Handle last segment
      currentSegment.push(points.length - 1);
      if (currentSegment.length >= 3) {
        segments.push(currentSegment);
      }
      
      console.log(`üõ£Ô∏è Detected ${segments.length} straight line segments with ${segments.reduce((sum, seg) => sum + seg.length - 2, 0)} reducible points`);
      return segments;
    }

    // Optimize only straight line segments, preserve curves
    function optimizeStraightLines(points) {
      if (points.length < 3) return points;
      
      const straightSegments = detectStraightLineSegments(points);
      
      if (straightSegments.length === 0) {
        console.log(`üåÄ No straight line segments found - preserving all ${points.length} points for route shape`);
        return points;
      }
      
      const result = [];
      let lastProcessedIndex = -1;
      
      for (const segment of straightSegments) {
        // Add points between segments (curves/turns)
        for (let i = lastProcessedIndex + 1; i < segment[0]; i++) {
          result.push(points[i]);
        }
        
        // Optimize this straight segment
        const segmentPoints = segment.map(index => points[index]);
        const optimizedSegment = douglasPeucker(segmentPoints, 0.00003); // Aggressive for straight lines
        
        // Add optimized segment (avoid duplicating junction points)
        if (result.length === 0 || result[result.length - 1] !== optimizedSegment[0]) {
          result.push(...optimizedSegment);
        } else {
          result.push(...optimizedSegment.slice(1));
        }
        
        lastProcessedIndex = segment[segment.length - 1];
      }
      
      // Add remaining points after last segment
      for (let i = lastProcessedIndex + 1; i < points.length; i++) {
        result.push(points[i]);
      }
      
      const reduction = ((points.length - result.length) / points.length) * 100;
      console.log(`üéØ Straight-line optimization: ${points.length} ‚Üí ${result.length} points (${reduction.toFixed(1)}% reduction)`);
      
      return result;
    }

    // Remove redundant points on straight lines (legacy function - kept for compatibility)
    function removeRedundantPoints(points) {
      if (points.length <= 2) return points;
      
      const result = [points[0]]; // Always keep first point
      
      for (let i = 1; i < points.length - 1; i++) {
        const prev = points[i - 1];
        const current = points[i];
        const next = points[i + 1];
        
        // Calculate if current point is on straight line between prev and next
        const straightLineDistance = perpendicularDistance(current, prev, next);
        
        // Keep point if it's not on a straight line (threshold: ~2 meters)
        if (straightLineDistance > 0.00002) {
          result.push(current);
        }
      }
      
      result.push(points[points.length - 1]); // Always keep last point
      return result;
    }

    // Save coordinates to local storage
    function saveToLocalStorage() {
      try {
        const data = {
          allCoordinates: allCoordinates,
          timestamp: new Date().toISOString(),
          optimizationCount: optimizationCount
        };
        localStorage.setItem('locationTracker_coordinates', JSON.stringify(data));
        console.log(`üíæ Saved ${allCoordinates.length} coordinates to local storage`);
      } catch (error) {
        console.error('Failed to save to local storage:', error);
      }
    }

    // Load coordinates from local storage
    function loadFromLocalStorage() {
      try {
        const stored = localStorage.getItem('locationTracker_coordinates');
        if (stored) {
          const data = JSON.parse(stored);
          allCoordinates = data.allCoordinates || [];
          optimizationCount = data.optimizationCount || 0;
          autoSyncCount = optimizationCount;
          autoSyncCountDisplay.textContent = optimizationCount;
          coordinates = allCoordinates.slice(-5);
          updateCoordinatesDisplay();
          console.log(`üì± Loaded ${allCoordinates.length} coordinates from local storage`);
        }
      } catch (error) {
        console.error('Failed to load from local storage:', error);
      }
    }

    // Show optimization status
    function showOptimizationStatus(original, optimized, percentage, status = 'applied') {
      autoSyncStatus.style.display = 'block';
      
      let statusColor = '#007bff';
      let statusIcon = 'üìä';
      let message = '';
      
      if (status === 'skipped') {
        statusColor = '#6c757d';
        statusIcon = 'üåÄ';
        message = `Shape preserved: ${original} points kept (curves/turns detected)`;
      } else {
        // Applied optimization
        if (percentage >= 50) {
          statusColor = '#28a745';
          statusIcon = 'üöÄ';
        } else if (percentage >= 20) {
          statusColor = '#ffc107';
          statusIcon = '‚ö°';
        } else if (percentage >= 5) {
          statusColor = '#007bff';
          statusIcon = 'üéØ';
        } else {
          statusColor = '#dc3545';
          statusIcon = '‚ö†Ô∏è';
        }
        message = `Route optimized: ${original} ‚Üí ${optimized} points (${percentage.toFixed(1)}% reduction)`;
      }
      
      autoSyncStatus.innerHTML = `
        <div class="sync-indicator">
          <div class="loading-spinner"></div>
          <span style="color: ${statusColor};">${statusIcon} ${message}</span>
        </div>
      `;
      
      setTimeout(() => {
        autoSyncStatus.style.display = 'none';
      }, 4000);
    }

    // Enhanced curve detection and analysis
    function detectCurvesAndTurns(points, angleThreshold = 0.3) {
      if (points.length < 3) return { curves: [], criticalPoints: [] };
      
      const curves = [];
      const criticalPoints = [];
      
      for (let i = 1; i < points.length - 1; i++) {
        const prev = points[i - 1];
        const current = points[i];
        const next = points[i + 1];
        
        // Calculate turn angle
        const angle = calculateTurnAngle(prev, current, next);
        
        // Detect significant turns/curves
        if (Math.abs(angle) > angleThreshold) {
          curves.push(i);
          criticalPoints.push({
            index: i,
            angle: angle,
            type: angle > angleThreshold ? 'left_turn' : 'right_turn',
            severity: Math.abs(angle)
          });
        }
        
        // Detect direction changes (important for route shape)
        if (i > 1) {
          const prevAngle = calculateTurnAngle(points[i - 2], points[i - 1], points[i]);
          const currentAngle = angle;
          
          // If direction change is significant, mark as critical
          if (Math.abs(prevAngle - currentAngle) > 0.5) {
            if (!criticalPoints.find(cp => cp.index === i)) {
              criticalPoints.push({
                index: i,
                angle: currentAngle,
                type: 'direction_change',
                severity: Math.abs(prevAngle - currentAngle)
              });
            }
          }
        }
      }
      
      console.log(`üåÄ Curve analysis: ${curves.length} turns detected, ${criticalPoints.length} critical points for route shape`);
      
      return { curves, criticalPoints };
    }

    // Calculate turn angle between three points
    function calculateTurnAngle(p1, p2, p3) {
      const v1 = { x: p2.lat - p1.lat, y: p2.lng - p1.lng };
      const v2 = { x: p3.lat - p2.lat, y: p3.lng - p2.lng };
      
      const dot = v1.x * v2.x + v1.y * v2.y;
      const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
      const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
      
      if (mag1 === 0 || mag2 === 0) return 0;
      
      return Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2))));
    }

    // Analyze route characteristics for debugging
    function analyzeRoute(points) {
      if (points.length < 2) return;
      
      let totalDistance = 0;
      let straightSegments = 0;
      
      // Use enhanced curve detection
      const curveAnalysis = detectCurvesAndTurns(points);
      const turns = curveAnalysis.curves.length;
      
      for (let i = 1; i < points.length; i++) {
        const dist = getDistance(points[i-1], points[i]);
        totalDistance += dist;
        
        // Count straight segments (points not in curves)
        if (!curveAnalysis.curves.includes(i)) {
          straightSegments++;
        }
      }
      
      console.log(`üó∫Ô∏è Enhanced route analysis: ${points.length} points, ${(totalDistance * 111000).toFixed(0)}m total, ${straightSegments} straight segments, ${turns} turns/curves`);
      
      return {
        totalDistance,
        straightSegments,
        turns,
        criticalPoints: curveAnalysis.criticalPoints,
        avgSegmentLength: totalDistance / (points.length - 1)
      };
    }

    // Calculate turn angle between three points (legacy function kept for compatibility)
    function calculateTurnAngleLegacy(p1, p2, p3) {
      const v1 = { x: p2.lat - p1.lat, y: p2.lng - p1.lng };
      const v2 = { x: p3.lat - p2.lat, y: p3.lng - p2.lng };
      
      const dot = v1.x * v2.x + v1.y * v2.y;
      const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
      const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
      
      if (mag1 === 0 || mag2 === 0) return 0;
      
      return Math.acos(Math.max(-1, Math.min(1, dot / (mag1 * mag2))));
    }

    // Timer Functions
    function startTimer() {
      startTime = Date.now();
      timerInterval = setInterval(updateTimer, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function updateTimer() {
      if (startTime) {
        const elapsed = Date.now() - startTime;
        const hours = Math.floor(elapsed / 3600000);
        const minutes = Math.floor((elapsed % 3600000) / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);
        
        timerDisplay.textContent = 
          `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }

    // Signal Status Functions
    function updateSignalStatus(accuracy, isGood = true) {
      if (isGood) {
        signalDot.className = 'signal-dot signal-good';
        signalText.textContent = 'GPS Signal: Strong';
      } else {
        signalDot.className = 'signal-dot signal-weak';
        signalText.textContent = 'GPS Signal: Weak';
      }
      
      signalDetails.textContent = 
        `Accuracy: ${accuracy}m | Last Update: ${new Date().toLocaleTimeString()}`;
    }

    function handleSignalLost() {
      signalDot.className = 'signal-dot signal-lost';
      signalText.textContent = 'GPS Signal: Lost';
      signalDetails.textContent = 'Connection lost - optimizing route and saving locally...';
      
      // Trigger route optimization when signal is lost for safety
      if (allCoordinates.length > 0) {
        optimizeRoute();
        saveToLocalStorage();
      }
    }

    // Auto-sync Functions (Every 2 Minutes for All Coordinates)
    async function autoSyncData(reason = 'Periodic sync') {
      const now = Date.now();
      if (!lastOptimizationTime) {
        lastOptimizationTime = now;
        return;
      }
      
      // Simple 2-minute optimization trigger for all coordinates
      const timeSinceLastOpt = now - lastOptimizationTime;
      const shouldOptimizeByTime = timeSinceLastOpt >= 120000; // 2 minutes
      
      if (shouldOptimizeByTime && allCoordinates.length >= 3) {
        console.log(`üîÑ Auto-optimization triggered: ${reason}`);
        console.log(`   - Time since last: ${(timeSinceLastOpt/1000).toFixed(1)}s`);
        console.log(`   - Current points: ${allCoordinates.length}`);
        
        optimizeRoute();
        lastOptimizationTime = now;
      } else if (allCoordinates.length < 3) {
        console.log(`‚è∏Ô∏è Optimization skipped - insufficient coordinates (${allCoordinates.length} < 3)`);
      } else {
        console.log(`‚è∏Ô∏è Optimization pending - time remaining: ${(120 - (timeSinceLastOpt/1000)).toFixed(1)}s`);
      }
    }

    // Final sync function for when recording stops
    async function finalSyncData(reason = 'Final sync') {
      if (allCoordinates.length === 0) {
        console.log('No coordinates to sync');
        return true;
      }

      autoSyncStatus.style.display = 'block';
      autoSyncStatus.innerHTML = `
        <div class="sync-indicator">
          <div class="loading-spinner"></div>
          <span>Sending ${allCoordinates.length} coordinates to server...</span>
        </div>
      `;
      
      try {
        // Send all coordinates in a single request
        await sendToAPI(API_ENDPOINTS.primary, allCoordinates, reason);
        
        console.log(`‚úÖ Successfully sent ${allCoordinates.length} coordinates to server`);
        
        // Clear data after successful sync
        allCoordinates = [];
        coordinates = [];
        optimizationCount = 0;
        autoSyncCount = 0;
        autoSyncCountDisplay.textContent = 0;
        
        // Clear local storage
        localStorage.removeItem('locationTracker_coordinates');
        
        updateCoordinatesDisplay();
        
        autoSyncStatus.innerHTML = `
          <div class="sync-indicator">
            <span style="color: #28a745;">‚úÖ All coordinates sent successfully!</span>
          </div>
        `;
        
        setTimeout(() => {
          autoSyncStatus.style.display = 'none';
        }, 3000);
        
        return true;
        
      } catch (error) {
        console.error('Final sync failed:', error);
        
        // Try backup endpoints
        const success = await tryBackupSync(reason);
        if (!success) {
          // Keep data in local storage for safety
          saveToLocalStorage();
          autoSyncStatus.innerHTML = `
            <div class="sync-indicator">
              <span style="color: #dc3545;">‚ö†Ô∏è Sync failed - data saved locally for retry</span>
            </div>
          `;
        }
        return success;
      }
    }

    async function tryBackupSync(reason) {
      const endpoints = [API_ENDPOINTS.backup, API_ENDPOINTS.emergency];
      
      for (const endpoint of endpoints) {
        try {
          await sendToAPI(endpoint, allCoordinates, reason + ' - backup');
          
          // Clear data after successful backup sync
          allCoordinates = [];
          coordinates = [];
          optimizationCount = 0;
          autoSyncCount = 0;
          autoSyncCountDisplay.textContent = 0;
          localStorage.removeItem('locationTracker_coordinates');
          updateCoordinatesDisplay();
          
          autoSyncStatus.innerHTML = `
            <div class="sync-indicator">
              <span style="color: #28a745;">‚úÖ Backup sync successful!</span>
            </div>
          `;
          
          return true;
        } catch (error) {
          console.error(`Backup sync failed for ${endpoint}:`, error);
        }
      }
      
      return false;
    }

    async function sendToAPI(endpoint, data, reason) {
      const busIdInput = document.getElementById('busIdInput');
      const busId = busIdInput.value.trim() || 'UNKNOWN';
      
      const payload = {
        busId: busId,
        routeCoordinates: data,
        timestamp: new Date().toISOString(),
        reason: reason,
        deviceInfo: {
          userAgent: navigator.userAgent,
          timestamp: Date.now()
        }
      };

      const response = await fetch(endpoint, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'X-Source': 'driver-recorder'
        },
        body: JSON.stringify(payload),
        timeout: 10000
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return response.text();
    }

    // Coordinates Display
    function updateCoordinatesDisplay() {
      // Show total coordinates collected
      coordinateCount.textContent = allCoordinates.length;
      
      if (allCoordinates.length === 0) {
        coordinatesPreview.innerHTML = 'No coordinates recorded yet...';
        return;
      }

      // Show last 5 coordinates for preview
      const recent = allCoordinates.slice(-5).reverse();
      coordinatesPreview.innerHTML = recent.map((coord, index) => 
        `<div class="coordinate-entry">
          ${allCoordinates.length - index}: [${coord.lat.toFixed(6)}, ${coord.lng.toFixed(6)}] 
          ${coord.time.split('T')[1].split('.')[0]}
        </div>`
      ).join('');
      
      // Add summary info
      if (allCoordinates.length > 5) {
        coordinatesPreview.innerHTML += `
          <div class="coordinate-entry" style="border-top: 1px solid #ddd; margin-top: 10px; padding-top: 10px; font-weight: bold;">
            Total: ${allCoordinates.length} coordinates collected
          </div>
        `;
      }
    }

    // Location Recording Functions
    function recordLocation() {
      if (!navigator.geolocation) {
        alert('Geolocation is not supported by your browser.');
        return;
      }

      const options = {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 5000
      };

      watchId = navigator.geolocation.watchPosition(
        (position) => {
          const { latitude, longitude, accuracy } = position.coords;
          const timestamp = new Date().toISOString();
          const coord = { lat: latitude, lng: longitude, time: timestamp, accuracy };
          
          // Add to main coordinates array
          allCoordinates.push(coord);
          
          // Keep only last 5 for preview
          coordinates = allCoordinates.slice(-5);
          
          updateCoordinatesDisplay();
          updateSignalStatus(accuracy, accuracy < 50);
          
          // Clear any existing signal lost timeout
          if (signalLostTimeout) {
            clearTimeout(signalLostTimeout);
          }
          
          // Simplified optimization triggers - check every 10 coordinates for 2-minute timer
          if (allCoordinates.length % 10 === 0) {
            autoSyncData('Regular optimization check');
          }
          
          // Save to local storage periodically for safety
          if (allCoordinates.length % 10 === 0) {
            saveToLocalStorage();
          }
        },
        (error) => {
          console.warn('Location error:', error.message);
          
          // Set timeout to handle signal lost
          signalLostTimeout = setTimeout(() => {
            handleSignalLost();
          }, 10000); // 10 seconds timeout
        },
        options
      );
    }

    // Event Listeners
    startBtn.addEventListener('click', () => {
      if (!isRecording) {
        // Validate Bus ID
        const busIdInput = document.getElementById('busIdInput');
        const busId = busIdInput.value.trim();
        
        if (!busId) {
          alert('‚ö†Ô∏è Please enter a Bus ID before starting recording.');
          busIdInput.focus();
          return;
        }
        
        // Show confirmation with database info
        const confirmMessage = `üöå Bus ID: ${busId}\n\nüìä Are you sure you want to start recording?\n\nThis will:\n‚úÖ Track your GPS location continuously\nüì° Send data to the database every 2 minutes\nüóÇÔ∏è Store route coordinates with optimization\n\nClick OK to start recording.`;
        
        if (!confirm(confirmMessage)) {
          return;
        }
        
        isRecording = true;
        recordingStatus.textContent = 'üî¥ Recording Active';
        recordingStatus.style.background = 'rgba(220, 53, 69, 0.8)';
        
        startBtn.disabled = true;
        stopBtn.disabled = false;
        
        // Disable Bus ID input during recording
        busIdInput.disabled = true;
        
        startTimer();
        recordLocation();
        
        console.log(`üöÄ Started location recording for Bus ID: ${busId}`);
      }
    });

    stopBtn.addEventListener('click', async () => {
      if (isRecording) {
        isRecording = false;
        recordingStatus.textContent = '‚≠ï Recording Stopped';
        recordingStatus.style.background = 'rgba(40, 167, 69, 0.8)';
        
        startBtn.disabled = false;
        stopBtn.disabled = true;
        
        // Re-enable Bus ID input
        const busIdInput = document.getElementById('busIdInput');
        busIdInput.disabled = false;
        
        stopTimer();
        
        if (watchId) {
          navigator.geolocation.clearWatch(watchId);
          watchId = null;
        }
        
        // Final optimization before sync
        if (allCoordinates.length > 2) {
          optimizeRoute();
        }
        
        // Final sync - send all optimized coordinates
        if (allCoordinates.length > 0) {
          try {
            const success = await finalSyncData('Final sync - recording stopped');
            if (success) {
              alert(`‚úÖ Recording completed! ${allCoordinates.length} optimized coordinates sent to server.`);
            } else {
              alert(`‚ö†Ô∏è Recording stopped but sync failed. ${allCoordinates.length} coordinates saved locally for retry.`);
            }
          } catch (error) {
            alert(`‚ö†Ô∏è Recording stopped but sync failed. ${allCoordinates.length} coordinates saved locally.`);
          }
        } else {
          alert('üìç Recording stopped. No coordinates were recorded.');
        }
        
        // Always clear localStorage after stopping (regardless of sync success)
        localStorage.removeItem('locationTracker_coordinates');
        console.log('üóëÔ∏è Local storage cleared after stopping recording');
        
        // Reset all coordinate arrays and counters
        allCoordinates = [];
        coordinates = [];
        optimizationCount = 0;
        autoSyncCount = 0;
        autoSyncCountDisplay.textContent = 0;
        coordinateCount.textContent = 0;
        
        // Update display to show empty state
        updateCoordinatesDisplay();
        
        console.log('‚èπÔ∏è Stopped recording and performed final sync');
      }
    });

    // Initialize
    loadFromLocalStorage(); // Load any existing coordinates
    updateCoordinatesDisplay();
    console.log('üéØ Advanced Driver Location Recorder with Route Optimization initialized');
    
    // Show recovery option if coordinates exist
    if (allCoordinates.length > 0) {
      recordingStatus.textContent = `üì± ${allCoordinates.length} coordinates recovered`;
      recordingStatus.style.background = 'rgba(255, 193, 7, 0.8)';
    }
  </script>
</body>
</html>